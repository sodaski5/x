import {
  AuthStatus,
  constants,
  decodeJwt,
  makeAuthObjectSerializable,
  sanitizeAuthObject,
  signedInAuthObject,
  signedOutAuthObject
} from "@clerk/backend";
import { withLogger } from "../utils/debugLogger";
import { API_KEY, API_URL, API_VERSION, SECRET_KEY } from "./clerkClient";
import { getAuthAuthHeaderMissing } from "./errors";
import { getAuthKeyFromRequest, getCookie, getHeader, injectSSRStateIntoObject } from "./utils";
const createGetAuth = ({
  debugLoggerName,
  noAuthStatusMessage
}) => withLogger(debugLoggerName, (logger) => {
  return (req, opts) => {
    const debug = getHeader(req, constants.Headers.EnableDebug) === "true";
    if (debug) {
      logger.enable();
    }
    const authStatus = getAuthKeyFromRequest(req, "AuthStatus");
    const authMessage = getAuthKeyFromRequest(req, "AuthMessage");
    const authReason = getAuthKeyFromRequest(req, "AuthReason");
    logger.debug("Headers debug", { authStatus, authMessage, authReason });
    if (!authStatus) {
      throw new Error(noAuthStatusMessage);
    }
    const options = {
      apiKey: opts?.apiKey || API_KEY,
      secretKey: opts?.secretKey || SECRET_KEY,
      apiUrl: API_URL,
      apiVersion: API_VERSION,
      authStatus,
      authMessage,
      authReason
    };
    logger.debug("Options debug", options);
    if (authStatus !== AuthStatus.SignedIn) {
      return signedOutAuthObject(options);
    }
    const jwt = parseJwt(req);
    logger.debug("JWT debug", jwt.raw.text);
    return signedInAuthObject(jwt.payload, { ...options, token: jwt.raw.text });
  };
});
const getAuth = createGetAuth({
  debugLoggerName: "getAuth()",
  noAuthStatusMessage: getAuthAuthHeaderMissing()
});
const buildClerkProps = (req, initState = {}) => {
  const authStatus = getAuthKeyFromRequest(req, "AuthStatus");
  const authMessage = getAuthKeyFromRequest(req, "AuthMessage");
  const authReason = getAuthKeyFromRequest(req, "AuthReason");
  const options = {
    apiKey: API_KEY,
    secretKey: SECRET_KEY,
    apiUrl: API_URL,
    apiVersion: API_VERSION,
    authStatus,
    authMessage,
    authReason
  };
  let authObject;
  if (!authStatus || authStatus !== AuthStatus.SignedIn) {
    authObject = signedOutAuthObject(options);
  } else {
    const { payload, raw } = parseJwt(req);
    authObject = signedInAuthObject(payload, { ...options, token: raw.text });
  }
  const sanitizedAuthObject = makeAuthObjectSerializable(sanitizeAuthObject({ ...authObject, ...initState }));
  return injectSSRStateIntoObject({}, sanitizedAuthObject);
};
const parseJwt = (req) => {
  const cookieToken = getCookie(req, constants.Cookies.Session);
  const headerToken = getHeader(req, "authorization")?.replace("Bearer ", "");
  return decodeJwt(cookieToken || headerToken || "");
};
export {
  buildClerkProps,
  createGetAuth,
  getAuth
};
//# sourceMappingURL=getAuth.js.map