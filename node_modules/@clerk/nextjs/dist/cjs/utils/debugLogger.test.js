"use strict";
var import_expect_type = require("expect-type");
var import_debugLogger = require("./debugLogger");
describe("withLogger", () => {
  let logger;
  beforeEach(() => {
    logger = {
      enable: jest.fn(),
      log: jest.fn(),
      commit: jest.fn()
    };
  });
  it("should return the type of the passed handler", function() {
    const handler = (0, import_debugLogger.withLogger)(
      () => logger,
      (logger2) => (opts) => {
        logger2.commit();
        return opts.name;
      }
    );
    (0, import_expect_type.expectTypeOf)(handler).toMatchTypeOf();
  });
  it("should log upon return of a sync function", function() {
    const handler = (0, import_debugLogger.withLogger)(
      () => logger,
      (logger2) => () => {
        logger2.enable();
        logger2.log("test");
        return "test";
      }
    );
    expect(logger.enable).not.toHaveBeenCalled();
    expect(logger.log).not.toHaveBeenCalled();
    expect(logger.commit).not.toHaveBeenCalled();
    handler();
    expect(logger.enable).toHaveBeenCalled();
    expect(logger.log).toHaveBeenCalled();
    expect(logger.commit).toHaveBeenCalled();
  });
  it("should log before an error is thrown inside of a sync function", function() {
    const handler = (0, import_debugLogger.withLogger)(
      () => logger,
      (logger2) => () => {
        logger2.enable();
        logger2.log("test");
        throw new Error();
      }
    );
    expect(logger.enable).not.toHaveBeenCalled();
    expect(logger.log).not.toHaveBeenCalled();
    expect(logger.commit).not.toHaveBeenCalled();
    try {
      handler();
    } catch (e) {
      expect(e).toBeDefined();
      expect(logger.enable).toHaveBeenCalled();
      expect(logger.log).toHaveBeenCalled();
      expect(logger.commit).toHaveBeenCalled();
    }
  });
  it("should log upon return of a async function", async function() {
    const handler = (0, import_debugLogger.withLogger)(
      () => logger,
      (logger2) => async () => {
        logger2.enable();
        logger2.log("test");
        const res = await new Promise((resolve) => {
          resolve("test");
        });
        return res;
      }
    );
    expect(logger.enable).not.toHaveBeenCalled();
    expect(logger.log).not.toHaveBeenCalled();
    expect(logger.commit).not.toHaveBeenCalled();
    await handler();
    expect(logger.enable).toHaveBeenCalled();
    expect(logger.log).toHaveBeenCalled();
    expect(logger.commit).toHaveBeenCalled();
  });
  it("should log before an error is thrown inside of an async function", async function() {
    const handler = (0, import_debugLogger.withLogger)(
      () => logger,
      (logger2) => async () => {
        logger2.enable();
        logger2.log("test");
        const res = await new Promise((_, reject) => {
          reject(new Error());
        });
        return res;
      }
    );
    expect(logger.enable).not.toHaveBeenCalled();
    expect(logger.log).not.toHaveBeenCalled();
    expect(logger.commit).not.toHaveBeenCalled();
    try {
      await handler();
    } catch (e) {
      expect(e).toBeDefined();
      expect(logger.enable).toHaveBeenCalled();
      expect(logger.log).toHaveBeenCalled();
      expect(logger.commit).toHaveBeenCalled();
    }
  });
});
//# sourceMappingURL=debugLogger.test.js.map