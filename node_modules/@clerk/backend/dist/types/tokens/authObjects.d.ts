import type { ActClaim, JwtPayload, ServerGetToken } from '@clerk/types';
import type { Organization, Session, User } from '../api';
import type { RequestState } from './authStatus';
import type { AuthenticateRequestOptions } from './request';
type AuthObjectDebugData = Partial<AuthenticateRequestOptions & RequestState>;
type AuthObjectDebug = () => unknown;
export type SignedInAuthObjectOptions = {
    /**
     * @deprecated Use `secretKey` instead.
     */
    apiKey?: string;
    secretKey?: string;
    apiUrl: string;
    apiVersion: string;
    token: string;
    session?: Session;
    user?: User;
    organization?: Organization;
};
export type SignedInAuthObject = {
    sessionClaims: JwtPayload;
    sessionId: string;
    session: Session | undefined;
    actor: ActClaim | undefined;
    userId: string;
    user: User | undefined;
    orgId: string | undefined;
    orgRole: string | undefined;
    orgSlug: string | undefined;
    organization: Organization | undefined;
    getToken: ServerGetToken;
    debug: AuthObjectDebug;
};
export type SignedOutAuthObject = {
    sessionClaims: null;
    sessionId: null;
    session: null;
    actor: null;
    userId: null;
    user: null;
    orgId: null;
    orgRole: null;
    orgSlug: null;
    organization: null;
    getToken: ServerGetToken;
    debug: AuthObjectDebug;
};
export type AuthObject = SignedInAuthObject | SignedOutAuthObject;
export declare function signedInAuthObject(sessionClaims: JwtPayload, options: SignedInAuthObjectOptions, debugData?: AuthObjectDebugData): SignedInAuthObject;
export declare function signedOutAuthObject(debugData?: AuthObjectDebugData): SignedOutAuthObject;
export declare function prunePrivateMetadata(resource?: {
    private_metadata: any;
} | {
    privateMetadata: any;
} | null): {
    private_metadata: any;
} | {
    privateMetadata: any;
} | null | undefined;
export declare function sanitizeAuthObject<T extends Record<any, any>>(authObject: T): T;
/**
 * Auth objects moving through the server -> client boundary need to be serializable
 * as we need to ensure that they can be transferred via the network as pure strings.
 * Some frameworks like Remix or Next (/pages dir only) handle this serialization by simply
 * ignoring any non-serializable keys, however Nextjs /app directory is stricter and
 * throws an error if a non-serializable value is found.
 */
export declare const makeAuthObjectSerializable: <T extends Record<string, unknown>>(obj: T) => T;
export {};
//# sourceMappingURL=authObjects.d.ts.map