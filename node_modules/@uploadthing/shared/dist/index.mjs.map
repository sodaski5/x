{"version":3,"sources":["../src/utils.ts","../src/file-types.ts","../src/error.ts"],"sourcesContent":["import { lookup } from \"@uploadthing/mime-types\";\n\nimport type { AllowedFileType } from \"./file-types\";\nimport type {\n  ExpandedRouteConfig,\n  FileData,\n  FileRouterInputConfig,\n  FileRouterInputKey,\n  FileSize,\n} from \"./types\";\n\nexport function isRouteArray(\n  routeConfig: FileRouterInputConfig,\n): routeConfig is FileRouterInputKey[] {\n  return Array.isArray(routeConfig);\n}\n\nexport function getDefaultSizeForType(fileType: FileRouterInputKey): FileSize {\n  if (fileType === \"image\") return \"4MB\";\n  if (fileType === \"video\") return \"16MB\";\n  if (fileType === \"audio\") return \"8MB\";\n  if (fileType === \"blob\") return \"8MB\";\n  if (fileType === \"pdf\") return \"4MB\";\n  if (fileType === \"text\") return \"64KB\";\n\n  return \"4MB\";\n}\n\n/**\n * This function takes in the user's input and \"upscales\" it to a full config\n *\n * Example:\n * ```ts\n * [\"image\"] => { image: { maxFileSize: \"4MB\", limit: 1 } }\n * ```\n */\nexport function fillInputRouteConfig(\n  routeConfig: FileRouterInputConfig,\n): ExpandedRouteConfig {\n  // If array, apply defaults\n  if (isRouteArray(routeConfig)) {\n    return routeConfig.reduce<ExpandedRouteConfig>((acc, fileType) => {\n      acc[fileType] = {\n        // Apply defaults\n        maxFileSize: getDefaultSizeForType(fileType),\n        maxFileCount: 1,\n      };\n      return acc;\n    }, {});\n  }\n\n  // Backfill defaults onto config\n  const newConfig: ExpandedRouteConfig = {};\n  const inputKeys = Object.keys(routeConfig) as FileRouterInputKey[];\n  inputKeys.forEach((key) => {\n    const value = routeConfig[key];\n    if (!value) throw new Error(\"Invalid config during fill\");\n\n    const defaultValues = {\n      maxFileSize: getDefaultSizeForType(key),\n      maxFileCount: 1,\n    };\n\n    newConfig[key] = { ...defaultValues, ...value };\n  }, {} as ExpandedRouteConfig);\n\n  return newConfig;\n}\n\nexport function getTypeFromFileName(\n  fileName: string,\n  allowedTypes: FileRouterInputKey[],\n) {\n  const mimeType = lookup(fileName);\n  if (!mimeType) {\n    throw new Error(\n      `Could not determine type for ${fileName}, presigned URL generation failed`,\n    );\n  }\n\n  // If the user has specified a specific mime type, use that\n  if (allowedTypes.some((type) => type.includes(\"/\"))) {\n    if (allowedTypes.includes(mimeType)) {\n      return mimeType;\n    }\n  }\n\n  // Otherwise, we have a \"magic\" type eg. \"image\" or \"video\"\n  const type = (\n    mimeType.toLowerCase() === \"application/pdf\"\n      ? \"pdf\"\n      : mimeType.split(\"/\")[0]\n  ) as AllowedFileType;\n\n  if (!allowedTypes.includes(type)) {\n    // Blob is a catch-all for any file type not explicitly supported\n    if (allowedTypes.includes(\"blob\")) {\n      return \"blob\";\n    } else {\n      throw new Error(`File type ${type} not allowed for ${fileName}`);\n    }\n  }\n\n  return type;\n}\n\nexport function generateUploadThingURL(path: `/${string}`) {\n  const host = process.env.CUSTOM_INFRA_URL ?? \"https://uploadthing.com\";\n  return `${host}${path}`;\n}\n\nexport const withExponentialBackoff = async <T>(\n  doTheThing: () => Promise<T | null>,\n  MAXIMUM_BACKOFF_MS = 64 * 1000,\n  MAX_RETRIES = 20,\n): Promise<T | null> => {\n  let tries = 0;\n  let backoffMs = 500;\n  let backoffFuzzMs = 0;\n\n  let result = null;\n  while (tries <= MAX_RETRIES) {\n    result = await doTheThing();\n    if (result !== null) return result;\n\n    tries += 1;\n    backoffMs = Math.min(MAXIMUM_BACKOFF_MS, backoffMs * 2);\n    backoffFuzzMs = Math.floor(Math.random() * 500);\n\n    if (tries > 3) {\n      console.error(\n        `[UT] Call unsuccessful after ${tries} tries. Retrying in ${Math.floor(\n          backoffMs / 1000,\n        )} seconds...`,\n      );\n    }\n\n    await new Promise((r) => setTimeout(r, backoffMs + backoffFuzzMs));\n  }\n\n  return null;\n};\n\nexport async function pollForFileData(\n  fileKey: string,\n  callback?: (json: any) => Promise<any>,\n) {\n  const queryUrl = generateUploadThingURL(`/api/pollUpload/${fileKey}`);\n\n  return withExponentialBackoff(async () => {\n    const res = await fetch(queryUrl);\n    const json = (await res.json()) as\n      | { status: \"done\"; fileData: FileData }\n      | { status: \"something else\" };\n\n    if (json.status !== \"done\") return null;\n\n    await callback?.(json);\n  });\n}\n\nexport function getUploadthingUrl() {\n  /**\n   * The pathname must be /api/uploadthing\n   * since we call that via webhook, so the user\n   * should not override that. Just the protocol and host\n   *\n   * User can override the callback url with the UPLOADTHING_URL env var,\n   * if they do, they should include the protocol\n   */\n  const uturl = process.env.UPLOADTHING_URL;\n  if (uturl) return `${uturl}/api/uploadthing`;\n\n  /**\n   * If the VERCEL_URL is set, we will fall back to that next.\n   * They don't set the protocol, however, so we need to add it\n   */\n  const vcurl = process.env.VERCEL_URL;\n  if (vcurl) return `https://${vcurl}/api/uploadthing`; // SSR should use vercel url\n\n  return `http://localhost:${process.env.PORT ?? 3000}/api/uploadthing`; // dev SSR should use localhost\n}\n\nexport const FILESIZE_UNITS = [\"B\", \"KB\", \"MB\", \"GB\"] as const;\nexport type FileSizeUnit = (typeof FILESIZE_UNITS)[number];\nexport const fileSizeToBytes = (input: string) => {\n  const regex = new RegExp(\n    `^(\\\\d+)(\\\\.\\\\d+)?\\\\s*(${FILESIZE_UNITS.join(\"|\")})$`,\n    \"i\",\n  );\n  const match = input.match(regex);\n\n  if (!match) {\n    return new Error(\"Invalid file size format\");\n  }\n\n  const sizeValue = parseFloat(match[1]);\n  const sizeUnit = match[3].toUpperCase() as FileSizeUnit;\n\n  if (!FILESIZE_UNITS.includes(sizeUnit)) {\n    throw new Error(\"Invalid file size unit\");\n  }\n  const bytes = sizeValue * Math.pow(1024, FILESIZE_UNITS.indexOf(sizeUnit));\n  return Math.floor(bytes);\n};\n","import * as z from \"zod\";\n\nimport { mimeTypes } from \"@uploadthing/mime-types/db\";\n\nexport const ALLOWED_FILE_TYPES = [\n  \"image\",\n  \"video\",\n  \"audio\",\n  \"pdf\",\n  \"text\",\n  \"blob\",\n] as const;\n\nexport type AllowedFileType = (typeof ALLOWED_FILE_TYPES)[number];\n\nfunction zodEnumFromObjKeys<K extends string>(\n  obj: Record<K, any>,\n): z.ZodEnum<[K, ...K[]]> {\n  const [firstKey, ...otherKeys] = Object.keys(obj) as K[];\n  return z.enum([firstKey, ...otherKeys]);\n}\n\nexport const MimeTypeZod = zodEnumFromObjKeys(mimeTypes);\n\nexport const InternalFileTypeValidator = z.enum(ALLOWED_FILE_TYPES);\nexport const InternalMimeTypeValidator = MimeTypeZod;\n\nexport const CombinedTypeValidator = z.union([\n  InternalFileTypeValidator,\n  InternalMimeTypeValidator,\n]);\n","import type { Json } from \"./types\";\n\nconst ERROR_CODES = {\n  BAD_REQUEST: 400,\n  NOT_FOUND: 404,\n\n  INTERNAL_SERVER_ERROR: 500,\n  INTERNAL_CLIENT_ERROR: 500,\n  URL_GENERATION_FAILED: 500,\n  UPLOAD_FAILED: 500,\n  MISSING_ENV: 500,\n  FILE_LIMIT_EXCEEDED: 500,\n} as const;\n\ntype ErrorCode = keyof typeof ERROR_CODES;\n\nfunction messageFromUnknown(cause: unknown, fallback?: string) {\n  if (typeof cause === \"string\") {\n    return cause;\n  }\n  if (cause instanceof Error) {\n    return cause.message;\n  }\n  if (\n    cause &&\n    typeof cause === \"object\" &&\n    \"message\" in cause &&\n    typeof cause.message === \"string\"\n  ) {\n    return cause.message;\n  }\n  return fallback ?? \"An unknown error occurred\";\n}\n\nexport class UploadThingError<\n  TShape extends Json = { message: string },\n> extends Error {\n  public readonly cause?: Error;\n  public readonly code: ErrorCode;\n  public readonly data?: TShape;\n\n  constructor(opts: {\n    code: keyof typeof ERROR_CODES;\n    message?: string;\n    cause?: unknown;\n    data?: TShape;\n  }) {\n    const message = opts.message ?? messageFromUnknown(opts.cause, opts.code);\n\n    super(message);\n    this.code = opts.code;\n    this.data = opts.data;\n\n    if (opts.cause instanceof Error) {\n      this.cause = opts.cause;\n    } else if (opts.cause instanceof Response) {\n      this.cause = new Error(\n        `Response ${opts.cause.status} ${opts.cause.statusText}`,\n      );\n    } else if (typeof opts.cause === \"string\") {\n      this.cause = new Error(opts.cause);\n    } else {\n      this.cause = undefined;\n    }\n  }\n\n  public static async fromResponse(response: Response) {\n    const json = (await response.json()) as Json;\n    let message: string | undefined = undefined;\n    if (json !== null && typeof json === \"object\" && !Array.isArray(json)) {\n      if (typeof json.message === \"string\") {\n        message = json.message;\n      } else if (typeof json.error === \"string\") {\n        message = json.error;\n      }\n    }\n    return new UploadThingError({\n      message,\n      code: getErrorTypeFromStatusCode(response.status),\n      cause: response,\n      data: json,\n    });\n  }\n\n  public static toObject(error: UploadThingError) {\n    return {\n      code: error.code,\n      message: error.message,\n      data: error.data,\n    };\n  }\n\n  public static serialize(error: UploadThingError) {\n    return JSON.stringify(UploadThingError.toObject(error));\n  }\n}\n\nexport function getStatusCodeFromError(error: UploadThingError<any>) {\n  return ERROR_CODES[error.code] ?? 500;\n}\n\nfunction getErrorTypeFromStatusCode(statusCode: number): ErrorCode {\n  for (const [code, status] of Object.entries(ERROR_CODES)) {\n    if (status === statusCode) {\n      return code as ErrorCode;\n    }\n  }\n  return \"INTERNAL_SERVER_ERROR\";\n}\n"],"mappings":"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","names":["type"]}