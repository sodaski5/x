import {
  createNextRouteHandler
} from "./chunk-L2Q5OFZU.mjs";
import {
  UPLOADTHING_VERSION,
  createBuilder
} from "./chunk-TZQC4LRV.mjs";
import {
  __export
} from "./chunk-4NWFEIIR.mjs";

// src/internal/types.ts
var unsetMarker = "unsetMarker";

// src/sdk/index.ts
var sdk_exports = {};
__export(sdk_exports, {
  deleteFiles: () => deleteFiles,
  getFileUrls: () => getFileUrls,
  listFiles: () => listFiles,
  renameFile: () => renameFile,
  uploadFiles: () => uploadFiles,
  uploadFilesFromUrl: () => uploadFilesFromUrl
});
import { generateUploadThingURL as generateUploadThingURL2, UploadThingError as UploadThingError2 } from "@uploadthing/shared";

// src/sdk/utils.ts
import {
  generateUploadThingURL,
  pollForFileData,
  UploadThingError
} from "@uploadthing/shared";
var uploadFilesInternal = async (data, opts) => {
  const fileData = data.files.map((file) => ({
    name: file.name,
    type: file.type,
    size: file.size
  }));
  const res = await fetch(generateUploadThingURL("/api/uploadFiles"), {
    method: "POST",
    headers: {
      "x-uploadthing-api-key": opts.apiKey,
      "x-uploadthing-version": opts.utVersion
    },
    cache: "no-store",
    body: JSON.stringify({
      files: fileData,
      metadata: data.metadata
    })
  });
  const json = await res.json();
  if (!res.ok || "error" in json) {
    throw UploadThingError.fromResponse(res);
  }
  const uploads = await Promise.allSettled(
    data.files.map(async (file, i) => {
      const { presignedUrl, fields, key, fileUrl } = json.data[i];
      if (!presignedUrl || !fields) {
        throw new UploadThingError({
          code: "URL_GENERATION_FAILED",
          message: "Failed to generate presigned URL",
          cause: JSON.stringify(json.data[i])
        });
      }
      const formData = new FormData();
      formData.append("Content-Type", file.type);
      Object.entries(fields).forEach(([key2, value]) => {
        formData.append(key2, value);
      });
      formData.append("file", file);
      const s3res = await fetch(presignedUrl, {
        method: "POST",
        body: formData,
        headers: new Headers({
          Accept: "application/xml"
        })
      });
      if (!s3res.ok) {
        throw new UploadThingError({
          code: "UPLOAD_FAILED",
          message: "Failed to upload file to storage provider",
          cause: s3res
        });
      }
      await pollForFileData(key);
      return {
        key,
        url: fileUrl,
        name: file.name,
        size: file.size
      };
    })
  );
  return uploads.map((upload) => {
    if (upload.status === "fulfilled") {
      const data2 = upload.value;
      return { data: data2, error: null };
    }
    const reason = upload.reason;
    const error = UploadThingError.toObject(reason);
    return { data: null, error };
  });
};

// src/sdk/index.ts
function guardServerOnly() {
  if (typeof window !== "undefined") {
    throw new UploadThingError2({
      code: "INTERNAL_SERVER_ERROR",
      message: "The `utapi` can only be used on the server."
    });
  }
}
function getApiKeyOrThrow() {
  if (!process.env.UPLOADTHING_SECRET) {
    throw new UploadThingError2({
      code: "MISSING_ENV",
      message: "Missing `UPLOADTHING_SECRET` env variable."
    });
  }
  return process.env.UPLOADTHING_SECRET;
}
var uploadFiles = async (files, metadata = {}) => {
  guardServerOnly();
  const filesToUpload = Array.isArray(files) ? files : [files];
  const uploads = await uploadFilesInternal(
    {
      files: filesToUpload,
      metadata
    },
    {
      apiKey: getApiKeyOrThrow(),
      utVersion: UPLOADTHING_VERSION
    }
  );
  const uploadFileResponse = Array.isArray(files) ? uploads : uploads[0];
  return uploadFileResponse;
};
var uploadFilesFromUrl = async (urls, metadata = {}) => {
  guardServerOnly();
  const fileUrls = Array.isArray(urls) ? urls : [urls];
  const formData = new FormData();
  formData.append("metadata", JSON.stringify(metadata));
  const filesToUpload = await Promise.all(
    fileUrls.map(async (url) => {
      if (typeof url === "string")
        url = new URL(url);
      const filename = url.pathname.split("/").pop() ?? "unknown-filename";
      const fileResponse = await fetch(url);
      if (!fileResponse.ok) {
        throw new UploadThingError2({
          code: "BAD_REQUEST",
          message: "Failed to download requested file.",
          cause: fileResponse
        });
      }
      const blob = await fileResponse.blob();
      return Object.assign(blob, { name: filename });
    })
  );
  const uploads = await uploadFilesInternal(
    {
      files: filesToUpload,
      metadata
    },
    {
      apiKey: getApiKeyOrThrow(),
      utVersion: UPLOADTHING_VERSION
    }
  );
  const uploadFileResponse = Array.isArray(urls) ? uploads : uploads[0];
  return uploadFileResponse;
};
var deleteFiles = async (fileKeys) => {
  guardServerOnly();
  if (!Array.isArray(fileKeys))
    fileKeys = [fileKeys];
  const res = await fetch(generateUploadThingURL2("/api/deleteFile"), {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "x-uploadthing-api-key": getApiKeyOrThrow(),
      "x-uploadthing-version": UPLOADTHING_VERSION
    },
    body: JSON.stringify({ fileKeys })
  });
  if (!res.ok) {
    throw new Error("Failed to delete files");
  }
  return res.json();
};
var getFileUrls = async (fileKeys) => {
  guardServerOnly();
  if (!Array.isArray(fileKeys))
    fileKeys = [fileKeys];
  const res = await fetch(generateUploadThingURL2("/api/getFileUrl"), {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "x-uploadthing-api-key": getApiKeyOrThrow(),
      "x-uploadthing-version": UPLOADTHING_VERSION
    },
    body: JSON.stringify({ fileKeys })
  });
  if (!res.ok) {
    throw new Error("Failed to get file urls");
  }
  return res.json().then(({ data }) => data);
};
var listFiles = async () => {
  guardServerOnly();
  const res = await fetch(generateUploadThingURL2("/api/listFiles"), {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "x-uploadthing-api-key": getApiKeyOrThrow(),
      "x-uploadthing-version": UPLOADTHING_VERSION
    }
  });
  const json = await res.json();
  if (!res.ok || "error" in json) {
    const message = "error" in json ? json.error : "Unknown error";
    throw new Error(message);
  }
  return json.files;
};
var renameFile = async (updates) => {
  guardServerOnly();
  if (!Array.isArray(updates))
    updates = [updates];
  const res = await fetch(generateUploadThingURL2("/api/renameFile"), {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "x-uploadthing-api-key": getApiKeyOrThrow(),
      "x-uploadthing-version": UPLOADTHING_VERSION
    },
    body: JSON.stringify({ updates })
  });
  const json = await res.json();
  if (!res.ok || "error" in json) {
    const message = "error" in json ? json.error : "Unknown error";
    throw new Error(message);
  }
  return json;
};

// src/internal/edge.ts
var createServerHandler = (...args) => {
  const handler = createNextRouteHandler(...args);
  const thisHandler = (method) => (event) => handler[method](event instanceof Request ? event : event.request);
  return {
    GET: thisHandler("GET"),
    POST: thisHandler("POST")
  };
};

// src/server.ts
var createUploadthing = (opts) => createBuilder(opts);
export {
  createServerHandler,
  createUploadthing,
  unsetMarker,
  sdk_exports as utapi
};
//# sourceMappingURL=server.mjs.map