{"version":3,"sources":["../package.json","../src/internal/error-formatter.ts","../src/internal/upload-builder.ts","../src/constants.ts","../src/internal/handler.ts","../src/internal/parser.ts"],"sourcesContent":["{\n  \"name\": \"uploadthing\",\n  \"version\": \"5.3.2\",\n  \"license\": \"MIT\",\n  \"exports\": {\n    \"./package.json\": \"./package.json\",\n    \"./client\": {\n      \"import\": \"./dist/client.mjs\",\n      \"types\": \"./dist/client.d.ts\"\n    },\n    \"./server\": {\n      \"import\": \"./dist/server.mjs\",\n      \"types\": \"./dist/server.d.ts\",\n      \"default\": \"./dist/server.mjs\"\n    },\n    \"./next\": {\n      \"import\": \"./dist/next.mjs\",\n      \"types\": \"./dist/next.d.ts\"\n    },\n    \"./next-legacy\": {\n      \"import\": \"./dist/next-legacy.mjs\",\n      \"types\": \"./dist/next-legacy.d.ts\"\n    }\n  },\n  \"files\": [\n    \"dist\"\n  ],\n  \"typesVersions\": {\n    \"*\": {\n      \"client\": [\n        \"dist/client.d.ts\"\n      ],\n      \"server\": [\n        \"dist/server.d.ts\"\n      ],\n      \"next\": [\n        \"dist/next.d.ts\"\n      ],\n      \"next-legacy\": [\n        \"dist/next-legacy.d.ts\"\n      ]\n    }\n  },\n  \"scripts\": {\n    \"lint\": \"eslint \\\"**/*.{ts,tsx}\\\" --max-warnings 0\",\n    \"build\": \"tsup\",\n    \"clean\": \"git clean -xdf dist node_modules\",\n    \"dev\": \"tsup --watch\",\n    \"test\": \"vitest run\",\n    \"test:watch\": \"vitest\",\n    \"typecheck\": \"tsc --noEmit\"\n  },\n  \"dependencies\": {\n    \"@uploadthing/mime-types\": \"^0.2.0\",\n    \"@uploadthing/shared\": \"^5.2.0\"\n  },\n  \"devDependencies\": {\n    \"@uploadthing/eslint-config\": \"0.1.0\",\n    \"@uploadthing/tsconfig\": \"0.1.0\",\n    \"@uploadthing/tsup-config\": \"0.1.0\",\n    \"eslint\": \"^8.42.0\",\n    \"next\": \"13.4.4\",\n    \"tsup\": \"6.7.0\",\n    \"type-fest\": \"^3.11.1\",\n    \"typescript\": \"5.1.3\",\n    \"vitest\": \"^0.30.1\",\n    \"zod\": \"^3.21.4\"\n  },\n  \"publishConfig\": {\n    \"access\": \"public\"\n  }\n}\n","import type { UploadThingError } from \"@uploadthing/shared\";\n\nexport function defaultErrorFormatter(error: UploadThingError) {\n  return {\n    message: error.message,\n  };\n}\n","import type {\n  FileRouterInputConfig,\n  Json,\n  UploadThingError,\n} from \"@uploadthing/shared\";\n\nimport { defaultErrorFormatter } from \"./error-formatter\";\nimport type {\n  AnyParams,\n  AnyRuntime,\n  UnsetMarker,\n  UploadBuilder,\n  UploadBuilderDef,\n  Uploader,\n} from \"./types\";\n\nfunction internalCreateBuilder<\n  TRuntime extends AnyRuntime = \"web\",\n  TErrorShape extends Json = { message: string },\n>(\n  initDef: Partial<UploadBuilderDef<any>> = {},\n): UploadBuilder<{\n  _input: UnsetMarker;\n  _metadata: UnsetMarker;\n  _runtime: TRuntime;\n  _errorShape: TErrorShape;\n}> {\n  const _def: UploadBuilderDef<AnyParams> = {\n    // Default router config\n    routerConfig: {\n      image: {\n        maxFileSize: \"4MB\",\n      },\n    },\n\n    inputParser: { parse: () => ({}), _input: {}, _output: {} },\n\n    middleware: () => ({}),\n\n    errorFormatter: initDef.errorFormatter || defaultErrorFormatter,\n\n    // Overload with properties passed in\n    ...initDef,\n  };\n\n  return {\n    input(userParser) {\n      return internalCreateBuilder({\n        ..._def,\n        inputParser: userParser,\n      }) as UploadBuilder<any>;\n    },\n    middleware(userMiddleware) {\n      return internalCreateBuilder({\n        ..._def,\n        middleware: userMiddleware,\n      }) as UploadBuilder<any>;\n    },\n    onUploadComplete(userUploadComplete) {\n      return {\n        _def,\n        resolver: userUploadComplete,\n      } as Uploader<any>;\n    },\n  };\n}\n\ntype InOut<\n  TRuntime extends AnyRuntime = \"web\",\n  TErrorShape extends Json = { message: string },\n> = (input: FileRouterInputConfig) => UploadBuilder<{\n  _input: UnsetMarker;\n  _metadata: UnsetMarker;\n  _runtime: TRuntime;\n  _errorShape: TErrorShape;\n}>;\n\nexport type CreateBuilderOptions<TErrorShape extends Json> = {\n  errorFormatter: (err: UploadThingError) => TErrorShape;\n};\n\nexport function createBuilder<\n  TRuntime extends AnyRuntime = \"web\",\n  TErrorShape extends Json = { message: string },\n>(opts?: CreateBuilderOptions<TErrorShape>): InOut<TRuntime, TErrorShape> {\n  return (input: FileRouterInputConfig) => {\n    return internalCreateBuilder<TRuntime, TErrorShape>({\n      routerConfig: input,\n      ...opts,\n    });\n  };\n}\n","import type { PackageJson } from \"type-fest\";\n\n// eslint-disable-next-line @typescript-eslint/no-var-requires\nconst packageJson = require(\"../package.json\") as PackageJson;\nif (!packageJson.version) throw new Error(\"no version found in package.json\");\nexport const UPLOADTHING_VERSION = packageJson.version;\n","import type { NextApiResponse } from \"next\";\n\nimport {\n  generateUploadThingURL,\n  getTypeFromFileName,\n  getUploadthingUrl,\n  fillInputRouteConfig as parseAndExpandInputConfig,\n  pollForFileData,\n  UploadThingError,\n} from \"@uploadthing/shared\";\nimport type {\n  ExpandedRouteConfig,\n  FileData,\n  FileRouterInputKey,\n  Json,\n  UploadedFile,\n} from \"@uploadthing/shared\";\n\nimport { UPLOADTHING_VERSION } from \"../constants\";\nimport { getParseFn } from \"./parser\";\nimport type { AnyRuntime, FileRouter } from \"./types\";\n\nconst fileCountLimitHit = (\n  files: string[],\n  routeConfig: ExpandedRouteConfig,\n) => {\n  const counts: { [k: string]: number } = {};\n\n  files.forEach((file) => {\n    const type = getTypeFromFileName(\n      file,\n      Object.keys(routeConfig) as FileRouterInputKey[],\n    ) as FileRouterInputKey;\n\n    if (!counts[type]) {\n      counts[type] = 1;\n    } else {\n      counts[type] += 1;\n    }\n  });\n\n  for (const _key in counts) {\n    const key = _key as FileRouterInputKey;\n    const count = counts[key];\n    const limit = routeConfig[key]?.maxFileCount;\n\n    if (!limit) {\n      console.error(routeConfig, key);\n      throw new UploadThingError({\n        code: \"BAD_REQUEST\",\n        message: \"Invalid config during file count\",\n        cause: `Expected route config to have a maxFileCount for key ${key} but none was found.`,\n      });\n    }\n\n    if (count > limit) {\n      return { limitHit: true, type: key, limit, count };\n    }\n  }\n\n  return { limitHit: false };\n};\n\nif (process.env.NODE_ENV === \"development\") {\n  console.log(\"[UT] UploadThing dev server is now running!\");\n}\n\nconst isValidResponse = (response: Response) => {\n  if (!response.ok) return false;\n  if (response.status >= 400) return false;\n  if (!response.headers.has(\"x-uploadthing-version\")) return false;\n\n  return true;\n};\n\nconst conditionalDevServer = async (fileKey: string) => {\n  if (process.env.NODE_ENV !== \"development\") return;\n\n  const fileData = await pollForFileData(\n    fileKey,\n    async (json: { fileData: FileData }) => {\n      const file = json.fileData;\n\n      let callbackUrl = file.callbackUrl + `?slug=${file.callbackSlug}`;\n      if (!callbackUrl.startsWith(\"http\"))\n        callbackUrl = \"http://\" + callbackUrl;\n\n      console.log(\"[UT] SIMULATING FILE UPLOAD WEBHOOK CALLBACK\", callbackUrl);\n\n      const response = await fetch(callbackUrl, {\n        method: \"POST\",\n        body: JSON.stringify({\n          status: \"uploaded\",\n          metadata: JSON.parse(file.metadata ?? \"{}\") as FileData[\"metadata\"],\n          file: {\n            url: `https://uploadthing.com/f/${encodeURIComponent(fileKey)}`,\n            key: fileKey,\n            name: file.fileName,\n            size: file.fileSize,\n          },\n        }),\n        headers: {\n          \"uploadthing-hook\": \"callback\",\n        },\n      });\n      if (isValidResponse(response)) {\n        console.log(\"[UT] Successfully simulated callback for file\", fileKey);\n      } else {\n        console.error(\n          \"[UT] Failed to simulate callback for file. Is your webhook configured correctly?\",\n          fileKey,\n        );\n      }\n      return file;\n    },\n  );\n\n  if (fileData !== null) return fileData;\n\n  console.error(`[UT] Failed to simulate callback for file ${fileKey}`);\n  throw new UploadThingError({\n    code: \"UPLOAD_FAILED\",\n    message: \"File took too long to upload\",\n  });\n};\n\nexport type RouterWithConfig<TRouter extends FileRouter> = {\n  router: TRouter;\n  config?: {\n    callbackUrl?: string;\n    uploadthingId?: string;\n    uploadthingSecret?: string;\n  };\n};\n\nexport const buildRequestHandler = <\n  TRouter extends FileRouter,\n  TRuntime extends AnyRuntime,\n>(\n  opts: RouterWithConfig<TRouter>,\n) => {\n  return async (input: {\n    req: Partial<Request> & { json: Request[\"json\"] };\n    res?: TRuntime extends \"pages\" ? NextApiResponse : undefined;\n  }) => {\n    const { req, res } = input;\n    const { router, config } = opts;\n    const preferredOrEnvSecret =\n      config?.uploadthingSecret ?? process.env.UPLOADTHING_SECRET;\n\n    // Get inputs from query and params\n    const params = new URL(req.url ?? \"\", getUploadthingUrl()).searchParams;\n    const uploadthingHook = req.headers?.get(\"uploadthing-hook\") ?? undefined;\n    const slug = params.get(\"slug\") ?? undefined;\n    const actionType = params.get(\"actionType\") ?? undefined;\n\n    // Validate inputs\n    if (!slug)\n      return new UploadThingError({\n        code: \"BAD_REQUEST\",\n        message: \"No slug provided\",\n      });\n\n    if (slug && typeof slug !== \"string\") {\n      return new UploadThingError({\n        code: \"BAD_REQUEST\",\n        message: \"`slug` must be a string\",\n        cause: `Expected slug to be of type 'string', got '${typeof slug}'`,\n      });\n    }\n    if (actionType && typeof actionType !== \"string\") {\n      return new UploadThingError({\n        code: \"BAD_REQUEST\",\n        message: \"`actionType` must be a string\",\n        cause: `Expected actionType to be of type 'string', got '${typeof actionType}'`,\n      });\n    }\n    if (uploadthingHook && typeof uploadthingHook !== \"string\") {\n      return new UploadThingError({\n        code: \"BAD_REQUEST\",\n        message: \"`uploadthingHook` must be a string\",\n        cause: `Expected uploadthingHook to be of type 'string', got '${typeof uploadthingHook}'`,\n      });\n    }\n\n    if (!preferredOrEnvSecret) {\n      return new UploadThingError({\n        code: \"BAD_REQUEST\",\n        message: `Please set your preferred secret in ${slug} router's config or set UPLOADTHING_SECRET in your env file`,\n        cause: \"No secret provided\",\n      });\n    }\n\n    const uploadable = router[slug];\n    if (!uploadable) {\n      return new UploadThingError({\n        code: \"NOT_FOUND\",\n        message: `No file route found for slug ${slug}`,\n      });\n    }\n\n    const reqBody = (await req.json()) as {\n      file: UploadedFile;\n      files: unknown;\n      metadata: Record<string, unknown>;\n      input?: Json;\n    };\n\n    if (uploadthingHook === \"callback\") {\n      // This is when we receive the webhook from uploadthing\n      await uploadable.resolver({\n        file: reqBody.file,\n        metadata: reqBody.metadata,\n      });\n\n      return { status: 200 };\n    }\n\n    if (!actionType || actionType !== \"upload\") {\n      // This would either be someone spamming or the AWS webhook\n      return new UploadThingError({\n        code: \"BAD_REQUEST\",\n        cause: `Invalid action type ${actionType}`,\n        message: `Expected \"upload\" but got \"${actionType}\"`,\n      });\n    }\n\n    try {\n      const { files, input: userInput } = reqBody as {\n        files: string[];\n        input: Json;\n      };\n\n      // validate the input\n      let parsedInput: Json = {};\n      try {\n        const inputParser = uploadable._def.inputParser;\n        parsedInput = await getParseFn(inputParser)(userInput);\n      } catch (error) {\n        return new UploadThingError({\n          code: \"BAD_REQUEST\",\n          message: \"Invalid input\",\n          cause: error,\n        });\n      }\n\n      let metadata: Json = {};\n      try {\n        metadata = await uploadable._def.middleware({\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n          req: req as any,\n          res,\n          input: parsedInput,\n        });\n      } catch (error) {\n        return new UploadThingError({\n          code: \"BAD_REQUEST\",\n          message: \"An error occured in the upload middleware\",\n          cause: error,\n        });\n      }\n\n      // Validate without Zod (for now)\n      if (!Array.isArray(files) || !files.every((f) => typeof f === \"string\"))\n        return new UploadThingError({\n          code: \"BAD_REQUEST\",\n          message: \"Files must be a string array\",\n          cause: `Expected files to be of type 'string[]', got '${JSON.stringify(\n            files,\n          )}'`,\n        });\n\n      // FILL THE ROUTE CONFIG so the server only has one happy path\n      const parsedConfig = parseAndExpandInputConfig(\n        uploadable._def.routerConfig,\n      );\n\n      const { limitHit, count, limit, type } = fileCountLimitHit(\n        files,\n        parsedConfig,\n      );\n\n      if (limitHit)\n        return new UploadThingError({\n          code: \"BAD_REQUEST\",\n          message: \"File limit exceeded\",\n          cause: `You uploaded ${count} files of type '${type}', but the limit for that type is ${limit}`,\n        });\n\n      const uploadthingApiResponse = await fetch(\n        generateUploadThingURL(\"/api/prepareUpload\"),\n        {\n          method: \"POST\",\n          body: JSON.stringify({\n            files: files,\n            routeConfig: parsedConfig,\n            metadata,\n            callbackUrl: config?.callbackUrl ?? getUploadthingUrl(),\n            callbackSlug: slug,\n          }),\n          headers: {\n            \"Content-Type\": \"application/json\",\n            \"x-uploadthing-api-key\": preferredOrEnvSecret,\n            \"x-uploadthing-version\": UPLOADTHING_VERSION,\n          },\n        },\n      );\n\n      if (!uploadthingApiResponse.ok) {\n        console.error(\"[UT] unable to get presigned urls\");\n        try {\n          const error = (await uploadthingApiResponse.json()) as unknown;\n          console.error(error);\n          return new UploadThingError({\n            code: \"BAD_REQUEST\",\n            cause: error,\n          });\n        } catch (cause) {\n          console.error(\"[UT] unable to parse response\");\n          return new UploadThingError({\n            code: \"URL_GENERATION_FAILED\",\n            message: \"Unable to get presigned urls\",\n            cause,\n          });\n        }\n      }\n\n      // This is when we send the response back to the user's form so they can submit the files\n      const parsedResponse = (await uploadthingApiResponse.json()) as {\n        presignedUrl: { url: string; fields: Record<string, string> }; // ripped type from S3 package\n        name: string;\n        key: string;\n      }[];\n\n      if (process.env.NODE_ENV === \"development\") {\n        for (const file of parsedResponse) {\n          void conditionalDevServer(file.key);\n        }\n      }\n\n      return { body: parsedResponse, status: 200 };\n    } catch (cause) {\n      console.error(\"[UT] middleware failed to run\");\n      console.error(cause);\n      return new UploadThingError({\n        code: \"BAD_REQUEST\",\n        message: `An error occured when running the middleware for the ${slug} route`,\n        cause,\n      });\n    }\n  };\n};\n\nexport const buildPermissionsInfoHandler = <TRouter extends FileRouter>(\n  opts: RouterWithConfig<TRouter>,\n) => {\n  return () => {\n    const r = opts.router;\n\n    const permissions = Object.keys(r).map((k) => {\n      const route = r[k];\n      const config = parseAndExpandInputConfig(route._def.routerConfig);\n      return {\n        slug: k as keyof TRouter,\n        config,\n      };\n    });\n\n    return permissions;\n  };\n};\n","import type { Json } from \"@uploadthing/shared\";\n\nimport type { MaybePromise } from \"./types\";\n\n// Don't want to use Zod cause it's an optional dependency\nexport type ParseFn<TType> = (input: unknown) => MaybePromise<TType>;\nexport type ParserZodEsque<TInput, TParsedInput extends Json> = {\n  _input: TInput;\n  _output: TParsedInput; // if using .transform etc\n  parse: ParseFn<TParsedInput>;\n};\n\n// In case we add support for more parsers later\nexport type JsonParser = ParserZodEsque<Json, Json>;\n\nexport function getParseFn<TParser extends JsonParser>(\n  parser: TParser,\n): ParseFn<TParser[\"_output\"]> {\n  if (typeof parser.parse === \"function\") {\n    return parser.parse;\n  }\n\n  throw new Error(\"Invalid parser\");\n}\n"],"mappings":"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","names":[]}