import {
  __commonJS
} from "./chunk-4NWFEIIR.mjs";

// package.json
var require_package = __commonJS({
  "package.json"(exports, module) {
    module.exports = {
      name: "uploadthing",
      version: "5.3.2",
      license: "MIT",
      exports: {
        "./package.json": "./package.json",
        "./client": {
          import: "./dist/client.mjs",
          types: "./dist/client.d.ts"
        },
        "./server": {
          import: "./dist/server.mjs",
          types: "./dist/server.d.ts",
          default: "./dist/server.mjs"
        },
        "./next": {
          import: "./dist/next.mjs",
          types: "./dist/next.d.ts"
        },
        "./next-legacy": {
          import: "./dist/next-legacy.mjs",
          types: "./dist/next-legacy.d.ts"
        }
      },
      files: [
        "dist"
      ],
      typesVersions: {
        "*": {
          client: [
            "dist/client.d.ts"
          ],
          server: [
            "dist/server.d.ts"
          ],
          next: [
            "dist/next.d.ts"
          ],
          "next-legacy": [
            "dist/next-legacy.d.ts"
          ]
        }
      },
      scripts: {
        lint: 'eslint "**/*.{ts,tsx}" --max-warnings 0',
        build: "tsup",
        clean: "git clean -xdf dist node_modules",
        dev: "tsup --watch",
        test: "vitest run",
        "test:watch": "vitest",
        typecheck: "tsc --noEmit"
      },
      dependencies: {
        "@uploadthing/mime-types": "^0.2.0",
        "@uploadthing/shared": "^5.2.0"
      },
      devDependencies: {
        "@uploadthing/eslint-config": "0.1.0",
        "@uploadthing/tsconfig": "0.1.0",
        "@uploadthing/tsup-config": "0.1.0",
        eslint: "^8.42.0",
        next: "13.4.4",
        tsup: "6.7.0",
        "type-fest": "^3.11.1",
        typescript: "5.1.3",
        vitest: "^0.30.1",
        zod: "^3.21.4"
      },
      publishConfig: {
        access: "public"
      }
    };
  }
});

// src/internal/error-formatter.ts
function defaultErrorFormatter(error) {
  return {
    message: error.message
  };
}

// src/internal/upload-builder.ts
function internalCreateBuilder(initDef = {}) {
  const _def = {
    // Default router config
    routerConfig: {
      image: {
        maxFileSize: "4MB"
      }
    },
    inputParser: { parse: () => ({}), _input: {}, _output: {} },
    middleware: () => ({}),
    errorFormatter: initDef.errorFormatter || defaultErrorFormatter,
    // Overload with properties passed in
    ...initDef
  };
  return {
    input(userParser) {
      return internalCreateBuilder({
        ..._def,
        inputParser: userParser
      });
    },
    middleware(userMiddleware) {
      return internalCreateBuilder({
        ..._def,
        middleware: userMiddleware
      });
    },
    onUploadComplete(userUploadComplete) {
      return {
        _def,
        resolver: userUploadComplete
      };
    }
  };
}
function createBuilder(opts) {
  return (input) => {
    return internalCreateBuilder({
      routerConfig: input,
      ...opts
    });
  };
}

// src/constants.ts
var packageJson = require_package();
if (!packageJson.version)
  throw new Error("no version found in package.json");
var UPLOADTHING_VERSION = packageJson.version;

// src/internal/handler.ts
import {
  generateUploadThingURL,
  getTypeFromFileName,
  getUploadthingUrl,
  fillInputRouteConfig as parseAndExpandInputConfig,
  pollForFileData,
  UploadThingError
} from "@uploadthing/shared";

// src/internal/parser.ts
function getParseFn(parser) {
  if (typeof parser.parse === "function") {
    return parser.parse;
  }
  throw new Error("Invalid parser");
}

// src/internal/handler.ts
var fileCountLimitHit = (files, routeConfig) => {
  var _a;
  const counts = {};
  files.forEach((file) => {
    const type = getTypeFromFileName(
      file,
      Object.keys(routeConfig)
    );
    if (!counts[type]) {
      counts[type] = 1;
    } else {
      counts[type] += 1;
    }
  });
  for (const _key in counts) {
    const key = _key;
    const count = counts[key];
    const limit = (_a = routeConfig[key]) == null ? void 0 : _a.maxFileCount;
    if (!limit) {
      console.error(routeConfig, key);
      throw new UploadThingError({
        code: "BAD_REQUEST",
        message: "Invalid config during file count",
        cause: `Expected route config to have a maxFileCount for key ${key} but none was found.`
      });
    }
    if (count > limit) {
      return { limitHit: true, type: key, limit, count };
    }
  }
  return { limitHit: false };
};
if (process.env.NODE_ENV === "development") {
  console.log("[UT] UploadThing dev server is now running!");
}
var isValidResponse = (response) => {
  if (!response.ok)
    return false;
  if (response.status >= 400)
    return false;
  if (!response.headers.has("x-uploadthing-version"))
    return false;
  return true;
};
var conditionalDevServer = async (fileKey) => {
  if (process.env.NODE_ENV !== "development")
    return;
  const fileData = await pollForFileData(
    fileKey,
    async (json) => {
      const file = json.fileData;
      let callbackUrl = file.callbackUrl + `?slug=${file.callbackSlug}`;
      if (!callbackUrl.startsWith("http"))
        callbackUrl = "http://" + callbackUrl;
      console.log("[UT] SIMULATING FILE UPLOAD WEBHOOK CALLBACK", callbackUrl);
      const response = await fetch(callbackUrl, {
        method: "POST",
        body: JSON.stringify({
          status: "uploaded",
          metadata: JSON.parse(file.metadata ?? "{}"),
          file: {
            url: `https://uploadthing.com/f/${encodeURIComponent(fileKey)}`,
            key: fileKey,
            name: file.fileName,
            size: file.fileSize
          }
        }),
        headers: {
          "uploadthing-hook": "callback"
        }
      });
      if (isValidResponse(response)) {
        console.log("[UT] Successfully simulated callback for file", fileKey);
      } else {
        console.error(
          "[UT] Failed to simulate callback for file. Is your webhook configured correctly?",
          fileKey
        );
      }
      return file;
    }
  );
  if (fileData !== null)
    return fileData;
  console.error(`[UT] Failed to simulate callback for file ${fileKey}`);
  throw new UploadThingError({
    code: "UPLOAD_FAILED",
    message: "File took too long to upload"
  });
};
var buildRequestHandler = (opts) => {
  return async (input) => {
    var _a;
    const { req, res } = input;
    const { router, config } = opts;
    const preferredOrEnvSecret = (config == null ? void 0 : config.uploadthingSecret) ?? process.env.UPLOADTHING_SECRET;
    const params = new URL(req.url ?? "", getUploadthingUrl()).searchParams;
    const uploadthingHook = ((_a = req.headers) == null ? void 0 : _a.get("uploadthing-hook")) ?? void 0;
    const slug = params.get("slug") ?? void 0;
    const actionType = params.get("actionType") ?? void 0;
    if (!slug)
      return new UploadThingError({
        code: "BAD_REQUEST",
        message: "No slug provided"
      });
    if (slug && typeof slug !== "string") {
      return new UploadThingError({
        code: "BAD_REQUEST",
        message: "`slug` must be a string",
        cause: `Expected slug to be of type 'string', got '${typeof slug}'`
      });
    }
    if (actionType && typeof actionType !== "string") {
      return new UploadThingError({
        code: "BAD_REQUEST",
        message: "`actionType` must be a string",
        cause: `Expected actionType to be of type 'string', got '${typeof actionType}'`
      });
    }
    if (uploadthingHook && typeof uploadthingHook !== "string") {
      return new UploadThingError({
        code: "BAD_REQUEST",
        message: "`uploadthingHook` must be a string",
        cause: `Expected uploadthingHook to be of type 'string', got '${typeof uploadthingHook}'`
      });
    }
    if (!preferredOrEnvSecret) {
      return new UploadThingError({
        code: "BAD_REQUEST",
        message: `Please set your preferred secret in ${slug} router's config or set UPLOADTHING_SECRET in your env file`,
        cause: "No secret provided"
      });
    }
    const uploadable = router[slug];
    if (!uploadable) {
      return new UploadThingError({
        code: "NOT_FOUND",
        message: `No file route found for slug ${slug}`
      });
    }
    const reqBody = await req.json();
    if (uploadthingHook === "callback") {
      await uploadable.resolver({
        file: reqBody.file,
        metadata: reqBody.metadata
      });
      return { status: 200 };
    }
    if (!actionType || actionType !== "upload") {
      return new UploadThingError({
        code: "BAD_REQUEST",
        cause: `Invalid action type ${actionType}`,
        message: `Expected "upload" but got "${actionType}"`
      });
    }
    try {
      const { files, input: userInput } = reqBody;
      let parsedInput = {};
      try {
        const inputParser = uploadable._def.inputParser;
        parsedInput = await getParseFn(inputParser)(userInput);
      } catch (error) {
        return new UploadThingError({
          code: "BAD_REQUEST",
          message: "Invalid input",
          cause: error
        });
      }
      let metadata = {};
      try {
        metadata = await uploadable._def.middleware({
          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
          req,
          res,
          input: parsedInput
        });
      } catch (error) {
        return new UploadThingError({
          code: "BAD_REQUEST",
          message: "An error occured in the upload middleware",
          cause: error
        });
      }
      if (!Array.isArray(files) || !files.every((f) => typeof f === "string"))
        return new UploadThingError({
          code: "BAD_REQUEST",
          message: "Files must be a string array",
          cause: `Expected files to be of type 'string[]', got '${JSON.stringify(
            files
          )}'`
        });
      const parsedConfig = parseAndExpandInputConfig(
        uploadable._def.routerConfig
      );
      const { limitHit, count, limit, type } = fileCountLimitHit(
        files,
        parsedConfig
      );
      if (limitHit)
        return new UploadThingError({
          code: "BAD_REQUEST",
          message: "File limit exceeded",
          cause: `You uploaded ${count} files of type '${type}', but the limit for that type is ${limit}`
        });
      const uploadthingApiResponse = await fetch(
        generateUploadThingURL("/api/prepareUpload"),
        {
          method: "POST",
          body: JSON.stringify({
            files,
            routeConfig: parsedConfig,
            metadata,
            callbackUrl: (config == null ? void 0 : config.callbackUrl) ?? getUploadthingUrl(),
            callbackSlug: slug
          }),
          headers: {
            "Content-Type": "application/json",
            "x-uploadthing-api-key": preferredOrEnvSecret,
            "x-uploadthing-version": UPLOADTHING_VERSION
          }
        }
      );
      if (!uploadthingApiResponse.ok) {
        console.error("[UT] unable to get presigned urls");
        try {
          const error = await uploadthingApiResponse.json();
          console.error(error);
          return new UploadThingError({
            code: "BAD_REQUEST",
            cause: error
          });
        } catch (cause) {
          console.error("[UT] unable to parse response");
          return new UploadThingError({
            code: "URL_GENERATION_FAILED",
            message: "Unable to get presigned urls",
            cause
          });
        }
      }
      const parsedResponse = await uploadthingApiResponse.json();
      if (process.env.NODE_ENV === "development") {
        for (const file of parsedResponse) {
          void conditionalDevServer(file.key);
        }
      }
      return { body: parsedResponse, status: 200 };
    } catch (cause) {
      console.error("[UT] middleware failed to run");
      console.error(cause);
      return new UploadThingError({
        code: "BAD_REQUEST",
        message: `An error occured when running the middleware for the ${slug} route`,
        cause
      });
    }
  };
};
var buildPermissionsInfoHandler = (opts) => {
  return () => {
    const r = opts.router;
    const permissions = Object.keys(r).map((k) => {
      const route = r[k];
      const config = parseAndExpandInputConfig(route._def.routerConfig);
      return {
        slug: k,
        config
      };
    });
    return permissions;
  };
};

export {
  defaultErrorFormatter,
  createBuilder,
  UPLOADTHING_VERSION,
  buildRequestHandler,
  buildPermissionsInfoHandler
};
//# sourceMappingURL=chunk-TZQC4LRV.mjs.map