{"version":3,"file":"valibot.module.js","sources":["../src/valibot.ts"],"sourcesContent":["import { toNestError } from '@hookform/resolvers';\nimport type { Resolver } from './types';\nimport {\n  BaseSchema,\n  BaseSchemaAsync,\n  ValiError,\n  parse,\n  parseAsync,\n} from 'valibot';\nimport { FieldErrors, FieldError } from 'react-hook-form';\n\ntype FlatErrors = Record<string, [FieldError, ...FieldError[]]>;\n\nconst parseErrors = (error: ValiError): FieldErrors => {\n  const errors = error.issues.reduce<FlatErrors>((flatErrors, issue) => {\n    if (issue.path) {\n      const path = issue.path.map(({ key }) => key).join('.');\n      flatErrors[path] = [\n        ...(flatErrors[path] || []),\n        {\n          message: issue.message,\n          type: issue.validation,\n        },\n      ];\n    }\n\n    return flatErrors;\n  }, {});\n\n  return Object.entries(errors).reduce<FieldErrors>((acc, [path, errors]) => {\n    const [firstError] = errors;\n    acc[path] = {\n      message: firstError.message,\n      type: firstError.type,\n    };\n\n    return acc;\n  }, {});\n};\n\nexport const valibotResolver: Resolver =\n  (\n    schema,\n    schemaOptions = {\n      abortEarly: false,\n      abortPipeEarly: false,\n    },\n    resolverOptions = {\n      mode: 'async',\n      raw: false,\n    },\n  ) =>\n  async (values, _, options) => {\n    try {\n      const { mode, raw } = resolverOptions;\n      const parsed =\n        mode === 'sync'\n          ? parse(schema as BaseSchema, values, schemaOptions)\n          : await parseAsync(\n              schema as BaseSchema | BaseSchemaAsync,\n              values,\n              schemaOptions,\n            );\n\n      return { values: raw ? values : parsed, errors: {} as FieldErrors };\n    } catch (error) {\n      if (error instanceof ValiError) {\n        return {\n          values: {},\n          errors: toNestError(parseErrors(error), options),\n        };\n      }\n\n      throw error;\n    }\n  };\n"],"names":["parseErrors","error","errors","issues","reduce","flatErrors","issue","path","map","_ref","key","join","concat","message","type","validation","Object","entries","acc","_ref2","firstError","valibotResolver","schema","schemaOptions","resolverOptions","values","abortEarly","abortPipeEarly","mode","raw","_","options","Promise","resolve","_temp","parsed","parse","parseAsync","then","_catch","ValiError","toNestError","e","reject"],"mappings":"iHAaA,IAAMA,EAAc,SAACC,GACnB,IAAMC,EAASD,EAAME,OAAOC,OAAmB,SAACC,EAAYC,GAC1D,GAAIA,EAAMC,KAAM,CACd,IAAMA,EAAOD,EAAMC,KAAKC,IAAI,SAAAC,UAAMA,EAAHC,GAAa,GAAEC,KAAK,KACnDN,EAAWE,GAAKK,GAAAA,OACVP,EAAWE,IAAS,GAAE,CAC1B,CACEM,QAASP,EAAMO,QACfC,KAAMR,EAAMS,aAGjB,CAED,OAAOV,CACT,EAAG,CAAA,GAEH,OAAOW,OAAOC,QAAQf,GAAQE,OAAoB,SAACc,EAAGC,GAAoB,IACjEC,EAD4DD,KACxC,GAM3B,OALAD,EAF2DC,EAAA,IAE/C,CACVN,QAASO,EAAWP,QACpBC,KAAMM,EAAWN,MAGZI,CACT,EAAG,GACL,EAEaG,EACX,SACEC,EACAC,EAIAC,GAKKC,YATQ,IAAbF,IAAAA,EAAgB,CACdG,YAAY,EACZC,gBAAgB,SAEH,IAAfH,IAAAA,EAAkB,CAChBI,KAAM,QACNC,KAAK,IAGFJ,SAAAA,EAAQK,EAAGC,GAAO,IAAIC,OAAAA,QAAAC,gCAAA,WACvBC,SAAAA,EAEIC,GASN,MAAO,CAAEV,OAAQI,EAAMJ,EAASU,EAAQjC,OAAQ,GAAoB,CAVpE,IAAQ0B,EAAcJ,EAAdI,KAAMC,EAAQL,EAARK,IAAwB,MAE3B,SAATD,EAAeM,EAAN,SAATN,EACIQ,EAAMd,EAAsBG,EAAQF,GAC9Bc,EACJf,EACAG,EACAF,IACDS,QAAAC,QANI,SAATL,EACIQ,EAAMd,EAAsBG,EAAQF,GAC9Bc,EACJf,EACAG,EACAF,IACDe,KAAAJ,EAGR,6DAb0BK,CAAA,EAa1B,SAAQtC,GACP,GAAIA,aAAiBuC,EACnB,MAAO,CACLf,OAAQ,GACRvB,OAAQuC,EAAYzC,EAAYC,GAAQ8B,IAI5C,MAAM9B,CACP,GACH,CAAC,MAAAyC,UAAAV,QAAAW,OAAAD,EAAA,CAAA,CAAA"}